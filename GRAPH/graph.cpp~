#include "head.h"

//------------------------------------------------------------------------// methods of class Node

int Node::numberOfFactors(){
  return v_fac.size();
};

//------------------------------------------------------------------------// methods of class Factor

Factor::Factor(int p_f, int p_type, int p_p) : f ( p_f ), type ( p_type ), p(p_p) {
  v_node.reserve(p);
}

double Factor::clause(int i, int j, int k){

  //this is the finite T clause
  /*    
  int s0   = (int)pow(-1.,i);
  int s1   = (int)pow(-1.,j);
  int s2   = (int)pow(-1.,k);
  double J = (int)pow(-1.,type);
  double beta=100;
  return exp(-beta*(1-J*s0*s1*s2));
  */
  
  //this is the T=0 clause  
  if(type)
    return i^j^k;
  else
    return !(i^j^k);
  
};

int Factor::numberOfNodes(){
  return v_node.size();
};

//------------------------------------------------------------------------// methods of class FactorGraph

FactorGraph::FactorGraph(int p_N, int p_p) : N ( p_N ), p ( p_p ) {
  v.reserve(N);
  for (int i = 0; i < N; ++i){
    v.push_back (Node(i));
  }
};

int FactorGraph::addFactor(int p_a, int p_type, vector<int> v_da){

  vector <int> v1 = v_da;
  std::sort(v1.begin(), v1.end());

  int flag=1;

  //before adding a factor we check that the factor does not already exists.
  //if the factor already exists, flag is set to 0. 
  //to this aim it is sufficient to check that the first node of v_da not appear in a factor with the two other nodes of v_da.
  for(vector<int>::iterator it_a = v[v_da[0]].v_fac.begin(); it_a != v[v_da[0]].v_fac.end(); it_a++){

    vector <int> v2 = F[*it_a].v_node;
    std::sort(v2.begin(), v2.end());
    if (v1 == v2){
      flag=0;
    }
  }
  
  if(flag){

    Factor a(p_a,p_type,p);

    for (int i=0; i<v_da.size(); i++)
      a.v_node.push_back(v_da[i]);
    
    F.push_back(a);
  
    for(int i=0; i<v_da.size(); i++)
      v[v_da[i]].v_fac.push_back(p_a);

  }

  return flag;

};

int FactorGraph::numberOfTotalFactors(){
  return F.size();
};

int FactorGraph::numberOfTotalNodes(){
  return N;
};

void FactorGraph::factorsOfNode(int i){
  cout << "node " << i << " has " << v[i].numberOfFactors() << " factors: " << endl;
  for (vector<int>::iterator it = v[i].v_fac.begin() ; it != v[i].v_fac.end(); ++it)
    cout << *it << endl;
};

void FactorGraph::nodesOfFactor(int a){
  cout << "factor " << a << " has " << F[a].numberOfNodes() << " nodes: " << endl;
  for (vector<int>::iterator it = F[a].v_node.begin() ; it != F[a].v_node.end(); ++it)
    cout << *it << endl;
};

//------------------------------------------------------------------------// function generating ErdosRenyi graphs

void ErdosRenyi(FactorGraph &G, int M){

  vector<int> v;
  int i,j,k;
  int N=G.N;
  int a=0;
  int type;
  int flag;

  while (a<M){
    i=rand() % N ;
    j=rand() % N ;
    k=rand() % N ;

    if (i!=j && i!=k && j!=k){ 
      v = make_vector<int>() << i << j << k;      
      if (2*rand()/RAND_MAX-1 > 0)
	type=1;
      else 
	type=0;

      flag=G.addFactor(a, type, v);
      if (flag) a++;
    }
  }

};

void PlantedErdosRenyi(FactorGraph &G, int M, vector<int> &ps){

  //ps is the planted solution;

  vector<int> v;
  int i,j,k;
  int N=G.N;
  int a=0;
  int type;
  int flag;

  while (a<M){
    i=rand() % N ;
    j=rand() % N ;
    k=rand() % N ;

    if (i!=j && i!=k && j!=k){
      v = make_vector<int>() << i << j << k;
      type = (ps[i]+ps[j]+ps[k]) % 2;

      //      cout << i << " " << j << " " << k << endl;
      //      cout << ps[i] << " " << ps[j] << " " << ps[k] << endl;
      //      cout << "type: " << type << endl;

      flag=G.addFactor(a, type, v);
      if (flag) a++;
    }

  }

};

//------------------------------------------------------------------------// Leaf removal algorithm


void LeafRemoval(FactorGraph &G, int verbose){

  int N=G.numberOfTotalNodes();
  int M=G.numberOfTotalFactors();
  int count=1, flag, errorflag;
  int l;

  //v_d[i]=0 on variables that are removed from the graph in a leaf removal strategy and 1 otherwise 
  //F_d[i]=0 on factors that are removed from the graph in a leaf removal strategy and 1 otherwise

  vector <int> v_d(N,1);
  vector <int> F_d(M,1);

  while (count>0){
    count=0;
    for (int i=0; i<N; i++){
      //here we select a node and we try to eliminate it, with the corresponding contraint to which it is still attached
      if(v_d[i]){

	flag=0;

	//here we check how many constraints are still attached to the node i
	l=0;
	for (vector<int>::iterator it_a = G.v[i].v_fac.begin(); it_a != G.v[i].v_fac.end(); it_a ++){
	  if (F_d[*it_a]==1)
	    l++;
	}

	if (l <= 1){
	  flag=1;
	  v_d[i]=0;

	  int errorflag = 0;
	  for(vector<int>::iterator it_a = G.v[i].v_fac.begin(); it_a != G.v[i].v_fac.end(); it_a++){
	    if(F_d[*it_a]){
	      F_d[*it_a]=0;
	      errorflag++;
	    }
	  }
	  //this is a check. errorflag has to be 1.
	  if(errorflag > 1)
	    cout << "error in leaf removal" << endl;
	}

	count += flag;
	//cout << i << " " << flag << endl;
      }
    }
  }

  for(int i=0; i<N; i++)
    G.v[i].d=v_d[i];

  for(int a=0; a<M; a++)
    G.F[a].d=F_d[a];

  if (verbose){
    cout << endl;
    cout << endl;
    cout << "2-core structure (d=1 on frozen variables) : " << endl;
    for (int i=0; i<N; i++)
      cout << "----- d: " << v_d[i] << endl;

    cout << endl;
    cout << endl;
  }

};

//------------------------------------------------------------------------// methods of class Messages
Messages::Messages(int p_q, FactorGraph& p_G) : q (p_q), G (p_G) {

  N=G.numberOfTotalNodes();
  M=G.numberOfTotalFactors();

  eta_NodeToFac.reserve(N);
  nu_FacToNode.reserve(M);
  marginal.reserve(N);
  bias.reserve(N);

  InitMessages();

};


void Messages::InitMessages(){

  //Init messages eta to uniform distributions                                                                                                                                                                
  for(vector<Node>::iterator it_i=G.v.begin(); it_i !=G.v.end(); ++it_i){
    int size_di=G.v[it_i->n].numberOfFactors();  //di is the set of factors attached to node i. size_di is the number of such factors                                                
    eta_NodeToFac[it_i->n].reserve(size_di);
    for (vector<int>::iterator it_a = G.v[it_i->n].v_fac.begin(); it_a != G.v[it_i->n].v_fac.end(); ++it_a){
      int index_a = distance (G.v[it_i->n].v_fac.begin(), it_a);
      vector <double> eta(q,1./q);
      eta_NodeToFac[it_i->n][index_a].reserve(q);
      eta_NodeToFac[it_i->n][index_a]=eta;
    }
  }

  //Init messages nu to 0.
  for(vector<Factor>::iterator it_a=G.F.begin(); it_a !=G.F.end(); ++it_a){
    int size_da=G.F[it_a->f].numberOfNodes();  //da is the set of nodes attached to factor a. size_da is the number of such nodes and should be p 
    nu_FacToNode[it_a->f].reserve(size_da);
    for (vector<int>::iterator it_i = G.F[it_a->f].v_node.begin(); it_i != G.F[it_a->f].v_node.end(); ++it_i){
      int index_i = distance (G.F[it_a->f].v_node.begin(), it_i);
      vector <double> nu(q,0.);
      nu_FacToNode[it_a->f][index_i].reserve(q);
      nu_FacToNode[it_a->f][index_i]=nu;
    }
  }

  //Set no bias 
  for(vector<Node>::iterator it_i=G.v.begin(); it_i !=G.v.end(); ++it_i){
    bias[it_i->n].reserve(q);
    vector <double> b(q,1./q);
    bias[it_i->n]=b;
  }

  //Init marginals to uniform distributions
  for(vector<Node>::iterator it_i=G.v.begin(); it_i !=G.v.end(); ++it_i){
    marginal[it_i->n].reserve(q);
    marginal[it_i->n]=bias[it_i->n];
  }

};

void Messages::nuUpdate (){

  for (vector<Factor>::iterator it_b = G.F.begin() ; it_b != G.F.end(); ++it_b){
    for (vector<int>::iterator it_i = G.F[it_b->f].v_node.begin() ; it_i != G.F[it_b->f].v_node.end(); ++it_i){
      //cout << "message from factor " << it_b->f << " to node " << *it_i << endl;
      //compute message nu_b_to_i
      int index_i = distance (G.F[it_b->f].v_node.begin(), it_i);
      vector <vector <double> > in_eta;
      for(vector<int>::iterator it_j = G.F[it_b->f].v_node.begin(); it_j != G.F[it_b->f].v_node.end(); ++it_j){
        if(*it_j!=*it_i){
          //cout << "j: " << *it_j << endl;
          vector<int>::iterator it = find(G.v[*it_j].v_fac.begin(), G.v[*it_j].v_fac.end(), it_b->f);
          int index_b = distance (G.v[*it_j].v_fac.begin(), it);
          in_eta.push_back(eta_NodeToFac[*it_j][index_b]);
        }
      }

      vector <double> nu(q,0.);
      //this part needs to be generalized to general kind of clauses.
      //now it is tailed to describe a 3-body interaction.
      for (int k0=0; k0<q; ++k0){
        for (int k1=0; k1<q; ++k1){
          for (int k2=0; k2<q; ++k2){
            nu[k0] += G.F[it_b->f].clause(k0,k1,k2) * in_eta[0][k1] * in_eta[1][k2];
          }
        }
      }
      //message nu_b_to_i
      nu_FacToNode[it_b->f][index_i] = nu;
    }
  }

};

void Messages::etaUpdate (){

  for (vector<Node>::iterator it_i = G.v.begin(); it_i != G.v.end(); ++it_i){
    for (vector<int>::iterator it_a = G.v[it_i->n].v_fac.begin(); it_a != G.v[it_i->n].v_fac.end(); ++it_a){
      //cout << "message from node " << it_i->n << " to factor " << *it_a << endl;
      //compute message eta_i_to_a
      int index_a = distance (G.v[it_i->n].v_fac.begin(), it_a);
      vector <double> fin_eta(q,1.);
      for(vector<int>::iterator it_b = G.v[it_i->n].v_fac.begin(); it_b != G.v[it_i->n].v_fac.end(); ++it_b){
        if(*it_b!=*it_a){
          //cout << "b: " << *it_b << endl;
          vector<int>::iterator it = find(G.F[*it_b].v_node.begin(), G.F[*it_b].v_node.end(), it_i->n);
          int index_i = distance (G.F[*it_b].v_node.begin(), it);
          for(int k0=0; k0<q; ++k0){
            fin_eta[k0] *= nu_FacToNode[*it_b][index_i][k0];
          }
	}
      }
      for(int k0=0; k0<q; ++k0){
	fin_eta[k0]*=bias[it_i->n][k0];
      }

      //message eta_i_to_a
      eta_NodeToFac[it_i->n][index_a] = fin_eta;
    }
  }

};

int Messages::etaNormalize(){

  int errorflag=1;

  for(vector<Node>::iterator it_i=G.v.begin(); it_i !=G.v.end(); ++it_i){
    for (vector<int>::iterator it_a = G.v[it_i->n].v_fac.begin(); it_a != G.v[it_i->n].v_fac.end(); ++it_a){
      int index_a = distance (G.v[it_i->n].v_fac.begin(), it_a);
      double sum=0.;
      for (int k=0; k<q; k++){
	sum+=eta_NodeToFac[it_i->n][index_a][k];
      }
      if(sum!=0)
	for (int k=0; k<q; k++){
	  eta_NodeToFac[it_i->n][index_a][k]/=sum;
	} 
      else{
	cout << "************************* ATTENTION: node " << it_i->n << " is receiving conflicting messages from factors " << endl;
	errorflag=0;
      }

    }
  }
  return errorflag;
};

void Messages::nodeMarginals(){

  for(vector<Node>::iterator it_i=G.v.begin(); it_i !=G.v.end(); ++it_i){
    vector <double> marg(q,1.);
    int size_di=G.v[it_i->n].numberOfFactors();  //di is the set of factors attached to node i. size_di is the number of such factors 
    for (vector<int>::iterator it_a = G.v[it_i->n].v_fac.begin(); it_a != G.v[it_i->n].v_fac.end(); ++it_a){
      vector<int>::iterator it = find(G.F[*it_a].v_node.begin(), G.F[*it_a].v_node.end(), it_i->n);
      int index_i = distance (G.F[*it_a].v_node.begin(), it);
      for (int k=0; k<q; k++){
        marg[k]*=nu_FacToNode[*it_a][index_i][k];
      }
    }
    for(int k=0; k<q; ++k){
      marg[k]*=bias[it_i->n][k];
    }

    double sum=0.;
    for (int k=0; k<q; k++){
      sum+=marg[k];
    }
    for (int k=0; k<q; k++){
      marg[k]/=sum;
    }

    marginal[it_i->n]=marg;
  }

};
 
//the three following methods of the class Messages print the state of the BP algorithm
void Messages::etaState(){

  cout << endl;
  cout << "---*---*---*---printing messages from nodes to factors---*---*---*---" << endl;

  for (vector<Node>::iterator it_i = G.v.begin(); it_i != G.v.end(); ++it_i){
    for (vector<int>::iterator it_a = G.v[it_i->n].v_fac.begin(); it_a != G.v[it_i->n].v_fac.end(); ++it_a){
      cout << "message from node " << it_i->n << " to factor " << *it_a << endl;
      int index_a = distance (G.v[it_i->n].v_fac.begin(), it_a);
      cout << eta_NodeToFac[it_i->n][index_a][0] << " " << eta_NodeToFac[it_i->n][index_a][1] << endl;
    }
  }

};

void Messages::nuState(){

  cout << endl;
  cout << "---*---*---*---printing messages from factors to nodes---*---*---*---" << endl;

  for (vector<Factor>::iterator it_b = G.F.begin() ; it_b != G.F.end(); ++it_b){
    for (vector<int>::iterator it_i = G.F[it_b->f].v_node.begin() ; it_i != G.F[it_b->f].v_node.end(); ++it_i){
      cout << "message from factor " << it_b->f << " to node " << *it_i << endl;
      int index_i = distance (G.F[it_b->f].v_node.begin(), it_i);
      cout << nu_FacToNode[it_b->f][index_i][0] << " " << nu_FacToNode[it_b->f][index_i][1] << endl;
    }
  }

};

void Messages::marginalState(){

  cout << endl;
  cout << "---*---*---*---printing marginals---*---*---*---" << endl;

  for (vector<Node>::iterator it_i = G.v.begin(); it_i != G.v.end(); ++it_i){
    cout << "marginal of node " << it_i->n << endl;
    cout << marginal[it_i->n][0] << " " << marginal[it_i->n][1] << endl;
  }

};

//------------------------------------------------------------------------// methods of class Messages

BP::BP(int p_q, FactorGraph& p_G, vector<int>& v_bias, vector<int>& v_q) : q (p_q), G (p_G), mess (q,G) {

  if(v_bias.size()){

    int size=v_bias.size();
    if (size != v_q.size()){
      cout << "error: v_q and v_bias have to have the same size!" << endl;
      return;
    }
    else{
      for (int i=0; i<size; i++){
        int n=v_bias[i];
        for (vector<int>::iterator it_a = G.v[n].v_fac.begin(); it_a != G.v[n].v_fac.end(); ++it_a){
          int index_a = distance (G.v[n].v_fac.begin(), it_a);
          vector <double> eta(q,0);
          //we bias eta's towards the index color specified in v_q[i]
          eta[v_q[i]]=1;
          mess.eta_NodeToFac[n][index_a]=eta;
        }
      }
    }

    setBias(v_bias, v_q);

  }

};

void BP::setBias(vector<int>& v_bias, vector<int>& v_q){

  //v_bias contains the indices of nodes that have to be biased
  //v_q contains the color towards which they have to be biased

  int size=v_bias.size();
  if (size != v_q.size()){
    cout << "error: v_q and v_bias have to have the same size!" << endl;
    return;
  }
  else{
    for (int i=0; i<size; i++){
      int n=v_bias[i];
      fixedSpins.push_back(n);
      vector <double> b(q,0);
      //we bias eta's towards the index color specified in v_q[i]

      b[v_q[i]]=1;
      mess.bias[n]=b;

      mess.marginal[n]=mess.bias[n];

    }
  }

};

int BP::BP_sweep(int verbose){

  mess.nuUpdate();
  mess.etaUpdate();
  int flag = mess.etaNormalize();
  if(verbose){
    mess.nodeMarginals();
    BP_print();
  }

  return flag;

};

void BP::BP_print(){

  mess.nuState();
  mess.etaState();
  mess.marginalState();

};

void BP::BP_decimation(int verbose=0){

  //g is the number of spins that get freezed at each iteration.
  //when there are no more spins to freeze, the iteration stops. 
  int g=1;
  int t=0;

  while (g>0){
    cout << "--------------------------------------time: " << t << "------------------------------------ " << endl;
    cout << endl;
    int flag = BP_sweep(verbose);

    if(!flag)
      break;

    g=fixSpins(verbose);
    t++;
  }

};

int BP::fixSpins(int verbose){

  int q=1;

  vector<int> v_bias;
  vector<int> v_q;

  for (vector<Factor>::iterator it_a = G.F.begin() ; it_a != G.F.end(); ++it_a){
    for (vector<int>::iterator it_i = G.F[it_a->f].v_node.begin() ; it_i != G.F[it_a->f].v_node.end(); ++it_i){
      int index_i = distance (G.F[it_a->f].v_node.begin(), it_i);
      if (mess.nu_FacToNode[it_a->f][index_i][q]==1.){
        int contains = find(fixedSpins.begin(), fixedSpins.end(), *it_i) != fixedSpins.end();
        if(!contains){
          v_bias.push_back(*it_i);
          v_q.push_back(1);
        }
	continue;
      }
      if (mess.nu_FacToNode[it_a->f][index_i][q]==0.){
        int contains = find(fixedSpins.begin(), fixedSpins.end(), *it_i) != fixedSpins.end();
        if(!contains){
          v_bias.push_back(*it_i);
          v_q.push_back(0);
        }
        continue;
      }
    }
  }
  if(v_bias.size() != 0)
    setBias(v_bias,v_q);

  if (verbose){
    cout << "*************** printing the nodes that gets freezed at this time step: " << endl;
    for(int i=0; i<v_bias.size(); i++)
      cout << v_bias[i] << " " << v_q[i] << endl;

    cout << endl;
    cout << endl;
  }
    
  return v_bias.size();

};


